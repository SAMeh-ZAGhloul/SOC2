enrichment_type: dynamic
write_mode: merge

transform: |
  .event.kind = "enrichment"
  .event.category = ["threat"]
  .event.type = ["indicator"]

  .threat.indicator.first_seen = to_timestamp!(.json.first_seen)
  .threat.indicator.last_seen, err = to_timestamp(.json.last_seen)
  .threat.indicator.type = "file"
  .threat.indicator.file.name = .json.file_name
  .threat.indicator.file.mime_type = .json.file_type_mime
  .threat.indicator.provider = .json.reporter
  .threat.indicator.geo.country_iso_code = .json.origin_country
  .threat.software.alias = [.json.signature]
  .threat.indicator.file.size = .json.file_size
  .threat.indicator.file.extension = .json.file_type

  .threat.indicator.file.hash.md5 = .json.md5_hash
  .threat.indicator.file.hash.sha256 = .json.sha256_hash
  .threat.indicator.file.hash.sha1 = .json.sha1_hash
  .threat.indicator.file.hash.sha384 = .json.sha3_384_hash

  .threat.indicator.file.pe.imphash = .json.imphash
  .threat.indicator.file.hash.ssdeep = .json.ssdeep
  .threat.indicator.file.hash.tlsh = .json.tlsh
  .threat.indicator.file.elf.telfhash = .json.telfhash

  for_each(array(.json.code_sign) ?? []) -> |i, cs| {
      .threat.indicator.file.x509.subject.common_name = push(array(.threat.indicator.file.x509.subject.common_name) ?? [], cs.subject_cn)
      .threat.indicator.file.x509.issuer.common_name = push(array(.threat.indicator.file.x509.issuer.common_name) ?? [], cs.issuer_cn)
      .threat.indicator.file.x509.public_key_algorithm = push(array(.threat.indicator.file.x509.public_key_algorithm) ?? [], cs.algorithm)
      .threat.indicator.file.x509.not_before = push(array(.threat.indicator.file.x509.not_before) ?? [], cs.valid_from)
      .threat.indicator.file.x509.not_after = push(array(.threat.indicator.file.x509.not_after) ?? [], cs.valid_to)
      .threat.indicator.file.x509.serial_number = push(array(.threat.indicator.file.x509.serial_number) ?? [], cs.serial_number)

      th_algo = downcase(string(cs.thumbprint_algorithm) ?? null) ?? null
      if th_algo != null {
          .threat.indicator.file.hash = set!({}, [th_algo], cs.thumbprint)
      }
  }

  .related.hash = compact([
      .threat.indicator.file.hash.md5,
      .threat.indicator.file.hash.sha256,
      .threat.indicator.file.hash.sha1,
      .threat.indicator.file.hash.sha384,
      .threat.indicator.file.hash.ssdeep,
      .threat.indicator.file.hash.tlsh,
      .threat.indicator.file.pe.imphash,
      .threat.indicator.file.elf.telfhash
  ])

  intel = .json.intelligence
  intel.downloads = to_int(intel.downloads) ?? null
  intel.uploads = to_int(intel.uploads) ?? null
  .abusech.malwarebazaar.intelligence = compact(intel)
  .tags = if is_string(.json.tags) {
    split(.json.tags, ",") ?? null
  } else { .json.tags }

schema:
  # All hashes are populated, use one as PK.
  primary_key: threat.indicator.file.hash.md5
  ecs_field_names:
    - ecs.version
    - event.kind
    - event.category
    - event.type
    - event.id
    - related
    - threat.indicator
    - threat.software
  fields:
    - name: abusech
      type:
        type: struct
        fields:
          - name: malwarebazaar
            type:
              type: struct
              fields:
                - name: intelligence
                  type:
                    type: struct
                    fields:
                      - name: uploads
                        type: int
                      - name: downloads
                        type: int
